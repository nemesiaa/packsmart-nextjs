// ---------- Generators & Datasource ----------
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

// ---------- Models ----------
model User {
  id        Int      @id @default(autoincrement())
  email     String   @unique
  password  String
  name      String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // 1-N : un user possède plusieurs packages
  packages Package[]

  posts    Post[]
}

model Package {
  id          Int      @id @default(autoincrement())
  name        String
  description String?
  weight      Float?
  dimensions  String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // FK -> User
  userId Int
  user   User @relation(fields: [userId], references: [id])

  // 1-N : inverse vers PackageItem (⚠️ c’était la partie manquante)
  items PackageItem[]

  @@index([userId])
}

model Item {
  id   Int    @id @default(autoincrement())
  name String

  // inverse de PackageItem.item (1-N)
  packageItems PackageItem[]
}

model PackageItem {
  id Int @id @default(autoincrement())

  // FK -> Package (obligatoire)
  packageId Int
  package   Package @relation(fields: [packageId], references: [id], onDelete: Cascade)

  // FK -> Item (optionnelle si l’objet vient d’un catalogue)
  itemId Int?
  item   Item? @relation(fields: [itemId], references: [id], onDelete: SetNull)

  // champs libres si l’utilisateur crée un objet “custom”
  customName   String?
  customWeight Float?

  createdAt DateTime @default(now())

  @@index([packageId])
  @@index([itemId])
}

model Post {
  id          Int      @id @default(autoincrement())
  createdAt   DateTime @default(now())
  userId      Int?
  userEmail   String
  userName    String?
  userAvatar  String?   // data URL ou URL publique
  imageData   String    // data URL (base64) ou URL (si plus tard tu passes par Scaleway Object Storage)
  description String?

  // relation optionnelle
  user        User?     @relation(fields: [userId], references: [id])
  // si user.id est Int ; adapte si c'est String/UUID
}
